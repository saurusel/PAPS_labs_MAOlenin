# Лабораторная работа №4 — REST API и автотесты Postman

**Тема:** Внутренний мерч‑магазин: каталог товаров и оформление заказов за поинты.

## Кратко о том, что сделано

Реализован и протестирован REST API для части корпоративного мерч‑магазина. 
API поддерживает базовый пользовательский сценарий: создать товар в каталоге → оформить заказ → обработать заказ по статусам → отменить заказ (если разрешено правилами).

### Почему без базы данных

В лабораторной работе сделана **in‑memory реализация** (данные хранятся в памяти приложения в словарях/списках). Это осознанное решение:
- упрощает запуск и демонстрацию;
- для полноценного продукта или MVP это легко заменить на PostgreSQL/SQLite с транзакциями.

## Технологии и инструменты

- **FastAPI + Uvicorn** — реализация REST API и автодокументация Swagger (`/docs`).
- **Postman** — выполнение запросов и автотесты (скрипты проверки статусов/JSON/полей).

## Принятые проектные решения

1. Версионирование API через префикс `/api/v1` для управляемого изменения контрактов.
2. Единый формат ошибок: JSON с объектом `error` (code/message/details).
3. REST‑стиль именования ресурсов: `products`, `orders`.
4. Упрощённая модель ролей через заголовок `X-Role` (`buyer`, `content_admin`, `fulfillment_admin`) — достаточно для демонстрации разграничения прав.
5. Упрощённая идентификация пользователя через заголовок `X-User-Id` (для роли buyer).
6. HTTP‑коды по смыслу: 201 — создание, 200 — успех, 403 — запрет, 404 — не найдено, 409 — конфликт состояния, 422 — ошибка валидации, 400 — недопустимая операция.
7. Заказ имеет управляемый жизненный цикл статусов; допустимые переходы проверяются на сервере.
8. Резервирование остатков выполняется при переводе заказа в статус «На проверке» (чтобы избежать «обещали, но товара уже нет»).
9. Списание поинтов выполняется при создании заказа; при отмене — возврат поинтов (упрощает демонстрацию и тестирование).
10. SKU товара уникален; повторное создание с тем же SKU вызывает конфликт (409).
11. Данные хранятся in‑memory (без БД) для лабораторной, чтобы упростить запуск и сосредоточиться на API и тестах.
12. Postman‑автотесты: на каждый endpoint минимум 2 сценария (позитивный и негативный), проверки статуса и структуры ответа.

## Как запустить API

1. Активировать виртуальное окружение и установить зависимости:
```bash
pip install fastapi uvicorn pydantic
```
2. Запустить сервер:
```bash
uvicorn app.main:app --reload
```
3. Проверить Swagger: `http://127.0.0.1:8000/docs`

## Сценарий тестирования и скриншоты (1–18)

Ниже описано, что делает каждый запрос, зачем он нужен и какой результат считается правильным. Под каждым шагом приложены соответствующие скриншоты.

## Почему в отчёте 18 запросов, хотя endpoint’ов 7

В Swagger описано **7 endpoint’ов** (уникальные сочетания *HTTP-метод + путь*).  
В отчёте приведены **18 запросов**, потому что здесь нумеруются не endpoint’ы, а **тестовые сценарии** (конкретные HTTP-вызовы с разными условиями: позитивный/негативный, разные роли, разные параметры).

Требование лабораторной — минимум **2 теста на каждый endpoint**, то есть при 7 endpoint’ах получается минимум **14 сценариев**.  
Количество увеличено до 18, потому что часть проверок требует **подготовить состояние системы**. Например, чтобы показать, что *отмена заказа запрещена после начала сборки*, нужно:
1) создать заказ,  
2) перевести его в «На проверке»,  
3) перевести в «Сборка»,  
4) и только после этого выполнить отмену и получить ожидаемую ошибку.

Поэтому запросы **15–17** в сценарии — это подготовка состояния (переводы по статусам), а **18** — целевой негативный тест отмены.

1) POST /products → запросы 1–2 (201 и 409)
2) GET /products → 3–4 (200 непусто и 200 пусто по поиску)
3) GET /products/{id} → 5–6 (200 и 404)
4) POST /orders → 7–8 (201 и 409)
5) GET /orders → 9–10 (200 и 403)
6) PUT /orders/{id}/status → 11–12 (200 и 403) + 16–17 (подготовка состояния “Сборка”)
7) DELETE /orders/{id} → 14 (успешная отмена) и 18 (отмена запрещена)

А 13 и 15 — это “создать заказ” специально под сценарии отмены.

## Сценарий тестирования и скриншоты (1–18)

Ниже описано, что делает каждый запрос, зачем он нужен и какой результат считается правильным. Под каждым шагом приложены соответствующие скриншоты.


### Шаг 1. POST /api/v1/products (201 Created) — создание товара

**Что делаем:** Отправляем запрос на создание товара с вариантом (SKU), роль `content_admin`.
**Зачем:** Подготавливаем данные каталога, чтобы далее было что заказывать; проверяем, что создание работает и API возвращает созданную сущность.
**Ожидаемый результат:** HTTP 201, в ответе JSON товара с `id`, `variants[0].sku`, тесты PASSED.

**Скриншоты:**
![Шаг 1](screenshots/1/photo_1_2026-02-26_13-27-27.jpg)
![Шаг 1](screenshots/1/photo_2_2026-02-26_13-27-27.jpg)
![Шаг 1](screenshots/1/photo_3_2026-02-26_13-27-27.jpg)
![Шаг 1](screenshots/1/photo_4_2026-02-26_13-27-27.jpg)

### Шаг 2. POST /api/v1/products (409 duplicate SKU) — попытка создать дубликат

**Что делаем:** Повторно отправляем создание товара с тем же `sku`.
**Зачем:** Проверяем бизнес‑ограничение «SKU уникален» и корректное поведение при конфликте данных.
**Ожидаемый результат:** HTTP 409 Conflict, в ответе `error.code=SKU_EXISTS`, тесты PASSED.

**Скриншоты:**
![Шаг 2](screenshots/2/photo_1_2026-02-26_13-27-50.jpg)
![Шаг 2](screenshots/2/photo_2_2026-02-26_13-27-50.jpg)
![Шаг 2](screenshots/2/photo_3_2026-02-26_13-27-50.jpg)
![Шаг 2](screenshots/2/photo_4_2026-02-26_13-27-50.jpg)

### Шаг 3. GET /api/v1/products (200) — список товаров

**Что делаем:** Запрашиваем полный список товаров без фильтров.
**Зачем:** Проверяем, что каталог доступен пользователям и возвращает массив товаров.
**Ожидаемый результат:** HTTP 200, массив не пустой, тесты PASSED.

**Скриншоты:**
![Шаг 3](screenshots/3/photo_1_2026-02-26_13-28-36.jpg)
![Шаг 3](screenshots/3/photo_2_2026-02-26_13-28-36.jpg)

### Шаг 4. GET /api/v1/products?q=... (200 empty) — поиск по имени

**Что делаем:** Запрашиваем список товаров с фильтром `q`, который заведомо не найдёт совпадений.
**Зачем:** Негативный сценарий для поиска: система должна корректно вернуть пустой результат, а не ошибку.
**Ожидаемый результат:** HTTP 200, массив пустой `[]`, тесты PASSED.

**Скриншоты:**
![Шаг 4](screenshots/4/photo_1_2026-02-26_13-29-03.jpg)
![Шаг 4](screenshots/4/photo_2_2026-02-26_13-29-03.jpg)
![Шаг 4](screenshots/4/photo_3_2026-02-26_13-29-03.jpg)

### Шаг 5. GET /api/v1/products/{productId} (200) — карточка товара

**Что делаем:** Получаем товар по `productId`, который был сохранён из шага 1.
**Зачем:** Проверяем работу параметра пути и согласованность данных (id совпадает).
**Ожидаемый результат:** HTTP 200, `id` совпадает с переменной окружения, тесты PASSED.

**Скриншоты:**
![Шаг 5](screenshots/5/photo_1_2026-02-26_13-29-19.jpg)
![Шаг 5](screenshots/5/photo_2_2026-02-26_13-29-19.jpg)

### Шаг 6. GET /api/v1/products/999999 (404) — товар не найден

**Что делаем:** Запрашиваем несуществующий id.
**Зачем:** Негативный сценарий: API должен вернуть понятную ошибку «не найдено».
**Ожидаемый результат:** HTTP 404, ответ с `error`, тесты PASSED.

**Скриншоты:**
![Шаг 6](screenshots/6/photo_1_2026-02-26_13-29-33.jpg)
![Шаг 6](screenshots/6/photo_2_2026-02-26_13-29-33.jpg)

### Шаг 7. POST /api/v1/orders (201) — создание заказа покупателем

**Что делаем:** Покупатель (`buyer`, `X-User-Id=u1`) создаёт заказ из 1 позиции по ранее созданному `sku`.
**Зачем:** Запускаем основной пользовательский сценарий: оформить заказ за поинты.
**Ожидаемый результат:** HTTP 201, статус заказа `Новый`, тесты PASSED, сохранён `orderIdStatus`.

**Скриншоты:**
![Шаг 7](screenshots/7/photo_1_2026-02-26_13-29-46.jpg)
![Шаг 7](screenshots/7/photo_2_2026-02-26_13-29-46.jpg)
![Шаг 7](screenshots/7/photo_3_2026-02-26_13-29-46.jpg)
![Шаг 7](screenshots/7/photo_4_2026-02-26_13-29-46.jpg)

### Шаг 8. POST /api/v1/orders (409) — недостаточно поинтов

**Что делаем:** Покупатель `u2` пытается создать заведомо дорогой заказ (qty=1000).
**Зачем:** Негативный сценарий: проверка ограничения по балансу поинтов.
**Ожидаемый результат:** HTTP 409, ответ с `error`, сообщение про недостаток поинтов/баллов, тесты PASSED.

**Скриншоты:**
![Шаг 8](screenshots/8/photo_1_2026-02-26_13-29-58.jpg)
![Шаг 8](screenshots/8/photo_2_2026-02-26_13-29-58.jpg)
![Шаг 8](screenshots/8/photo_3_2026-02-26_13-29-58.jpg)
![Шаг 8](screenshots/8/photo_4_2026-02-26_13-29-58.jpg)

### Шаг 9. GET /api/v1/orders (200) — список заказов покупателя

**Что делаем:** Покупатель `u1` запрашивает список заказов.
**Зачем:** Проверяем, что пользователь видит свои заказы и возвращается массив.
**Ожидаемый результат:** HTTP 200, массив не пустой, тесты PASSED.

**Скриншоты:**
![Шаг 9](screenshots/9/photo_1_2026-02-26_13-30-07.jpg)
![Шаг 9](screenshots/9/photo_2_2026-02-26_13-30-07.jpg)
![Шаг 9](screenshots/9/photo_3_2026-02-26_13-30-07.jpg)

### Шаг 10. GET /api/v1/orders (403) — запрет для роли content_admin

**Что делаем:** Отправляем запрос списка заказов с ролью `content_admin`.
**Зачем:** Негативный сценарий: доступ к заказам должен быть ограничен ролями.
**Ожидаемый результат:** HTTP 403, ответ с `error`, тесты PASSED.

**Скриншоты:**
![Шаг 10](screenshots/10/photo_1_2026-02-26_13-30-18.jpg)
![Шаг 10](screenshots/10/photo_2_2026-02-26_13-30-18.jpg)
![Шаг 10](screenshots/10/photo_3_2026-02-26_13-30-18.jpg)

### Шаг 11. PUT /api/v1/orders/{orderIdStatus}/status (200) — перевод в «На проверке»

**Что делаем:** Админ выдачи (`fulfillment_admin`) переводит заказ в статус «На проверке».
**Зачем:** Проверяем управляемый процесс обработки заказа и правило резервирования на этом шаге.
**Ожидаемый результат:** HTTP 200, статус «На проверке», тесты PASSED.

**Скриншоты:**
![Шаг 11](screenshots/11/photo_1_2026-02-26_13-31-30.jpg)
![Шаг 11](screenshots/11/photo_2026-02-26_13-32-08.jpg)
![Шаг 11](screenshots/11/photo_2_2026-02-26_13-31-30.jpg)
![Шаг 11](screenshots/11/photo_3_2026-02-26_13-31-30.jpg)

### Шаг 12. PUT /api/v1/orders/{orderIdStatus}/status (403) — запрет смены статуса покупателем

**Что делаем:** Покупатель пытается сменить статус заказа.
**Зачем:** Негативный сценарий: смена статусов доступна только админу выдачи.
**Ожидаемый результат:** HTTP 403, ответ с `error`, тесты PASSED.

**Скриншоты:**
![Шаг 12](screenshots/12/photo_1_2026-02-26_13-40-45.jpg)
![Шаг 12](screenshots/12/photo_2_2026-02-26_13-40-45.jpg)
![Шаг 12](screenshots/12/photo_3_2026-02-26_13-40-45.jpg)
![Шаг 12](screenshots/12/photo_4_2026-02-26_13-40-45.jpg)

### Шаг 13. POST /api/v1/orders (201) — отдельный заказ для отмены

**Что делаем:** Создаём новый заказ пользователем `u1`, чтобы на следующем шаге показать отмену.
**Зачем:** Готовим состояние системы для позитивного теста отмены.
**Ожидаемый результат:** HTTP 201, сохранён `orderIdCancel`, тесты PASSED.

**Скриншоты:**
![Шаг 13](screenshots/13/photo_1_2026-02-26_13-34-35.jpg)
![Шаг 13](screenshots/13/photo_2_2026-02-26_13-34-35.jpg)
![Шаг 13](screenshots/13/photo_3_2026-02-26_13-34-35.jpg)
![Шаг 13](screenshots/13/photo_4_2026-02-26_13-34-35.jpg)

### Шаг 14. DELETE /api/v1/orders/{orderIdCancel} (200) — отмена разрешена

**Что делаем:** Покупатель `u1` отменяет заказ в разрешённом статусе.
**Зачем:** Проверяем бизнес‑правило «отмена возможна только в Новый/На проверке» и корректный возврат поинтов.
**Ожидаемый результат:** HTTP 200, статус `Отменен`, тесты PASSED.

**Скриншоты:**
![Шаг 14](screenshots/14/photo_1_2026-02-26_13-36-49.jpg)
![Шаг 14](screenshots/14/photo_2_2026-02-26_13-36-49.jpg)
![Шаг 14](screenshots/14/photo_3_2026-02-26_13-36-49.jpg)

### Шаг 15. POST /api/v1/orders (201) — заказ для сценария «отмена запрещена»

**Что делаем:** Создаём новый заказ и сохраняем `orderIdLocked`.
**Зачем:** Готовим заказ, который затем доведём до статуса, где отмена запрещена.
**Ожидаемый результат:** HTTP 201, тесты PASSED.

**Скриншоты:**
![Шаг 15](screenshots/15/photo_1_2026-02-26_13-37-01.jpg)
![Шаг 15](screenshots/15/photo_2_2026-02-26_13-37-01.jpg)
![Шаг 15](screenshots/15/photo_3_2026-02-26_13-37-01.jpg)
![Шаг 15](screenshots/15/photo_4_2026-02-26_13-37-01.jpg)

### Шаг 16. PUT /api/v1/orders/{orderIdLocked}/status (200) — перевод в «На проверке»

**Что делаем:** Админ выдачи переводит заказ в «На проверке».
**Зачем:** Часть подготовки к негативному сценарию отмены: заказ начинает обрабатываться.
**Ожидаемый результат:** HTTP 200, тесты PASSED.

**Скриншоты:**
![Шаг 16](screenshots/16/photo_1_2026-02-26_13-38-15.jpg)
![Шаг 16](screenshots/16/photo_2_2026-02-26_13-38-15.jpg)
![Шаг 16](screenshots/16/photo_3_2026-02-26_13-38-15.jpg)
![Шаг 16](screenshots/16/photo_4_2026-02-26_13-38-15.jpg)

### Шаг 17. PUT /api/v1/orders/{orderIdLocked}/status (200) — перевод в «Сборка»

**Что делаем:** Админ выдачи переводит заказ в «Сборка».
**Зачем:** После начала сборки отмена должна быть запрещена — это мы проверим на следующем шаге.
**Ожидаемый результат:** HTTP 200, статус `Сборка`, тесты PASSED.

**Скриншоты:**
![Шаг 17](screenshots/17/photo_1_2026-02-26_13-39-31.jpg)
![Шаг 17](screenshots/17/photo_2_2026-02-26_13-39-31.jpg)
![Шаг 17](screenshots/17/photo_3_2026-02-26_13-39-31.jpg)
![Шаг 17](screenshots/17/photo_4_2026-02-26_13-39-31.jpg)

### Шаг 18. DELETE /api/v1/orders/{orderIdLocked} (400) — отмена запрещена

**Что делаем:** Покупатель пытается отменить заказ после начала сборки.
**Зачем:** Негативный сценарий: подтверждаем, что бизнес‑правило отмены соблюдается.
**Ожидаемый результат:** HTTP 400, ответ с `error`, сообщение про запрет отмены, тесты PASSED.

**Скриншоты:**
![Шаг 18](screenshots/18/photo_1_2026-02-26_13-40-14.jpg)
![Шаг 18](screenshots/18/photo_2_2026-02-26_13-40-14.jpg)
![Шаг 18](screenshots/18/photo_3_2026-02-26_13-40-14.jpg)
